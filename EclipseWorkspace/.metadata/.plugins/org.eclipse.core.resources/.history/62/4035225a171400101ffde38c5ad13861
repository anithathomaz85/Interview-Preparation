package gts;

public class Q36_FlightPath {
	36. 	Find the flight paths between source to destination airport.
	 List of airports {A, B, C, D, E}
	 Flight path list {A-C, B-D, B-C, B-E, A-B, C-D}
	 Available paths to go from A to D -> A-B-D, A-B-C-D, A-C-D

package com.ust.gts.dailycoding.day4;

import java.util.ArrayList;

import java.util.HashMap;

import java.util.List;

import java.util.Map;


public class FlightPath {

	// Method to add flight connections

	private static void addFlight(Map<String, List<String>> graph, String from, String to) {

		graph.computeIfAbsent(from, k -> new ArrayList<>()).add(to);

	}

	// Recursive DFS to find all paths

	private static void findAllPaths(Map<String, List<String>> graph, String current, String destination,

			List<String> path, List<List<String>> allPaths) {

		if (current.equals(destination)) {

			allPaths.add(new ArrayList<>(path));

			return;

		}

		if (!graph.containsKey(current))

			return;

		for (String neighbor : graph.get(current)) {

			if (!path.contains(neighbor)) { // Avoid cycles

				path.add(neighbor);

				findAllPaths(graph, neighbor, destination, path, allPaths);

				path.remove(path.size() - 1); // Backtrack

			}

		}

	}

	// Driver method

	public static void main(String[] args) {

		// Step 1: Define the graph (flight map)

		Map<String, List<String>> graph = new HashMap<>();

		addFlight(graph, "A", "C");

		addFlight(graph, "B", "D");

		addFlight(graph, "B", "C");

		addFlight(graph, "B", "E");

		addFlight(graph, "A", "B");

		addFlight(graph, "C", "D");

		String source = "A";

		String destination = "D";

		List<String> currentPath = new ArrayList<>();

		List<List<String>> allPaths = new ArrayList<>();

		currentPath.add(source);

		// Step 2: Find all paths

		findAllPaths(graph, source, destination, currentPath, allPaths);

		// Step 3: Print all valid paths

		System.out.println("Available paths from " + source + " to " + destination + ":");

		for (List<String> path : allPaths) {

			System.out.println(path);

		}

	}

}


37. â€ƒPrint all permutation of a string.
         Input: String s = "ABC"
	 Output: ABC ACB BAC BCA CAB CBA

package com.ust.gts.dailycoding.day4;

import java.util.HashSet;

import java.util.Set;


public class PermutationOfAString {

	public static Set<String> permutation(String str) {

		// create a set to avoid duplicate permutation

		Set<String> permutations = new HashSet<String>();

		// check if string is null

		if (str == null) {

			return null;

		} else if (str.length() == 0) {

			// terminating condition for recursion

			permutations.add("");

			return permutations;

		}

		// get the first character

		char first = str.charAt(0);

		// get the remaining substring

		String sub = str.substring(1);

		// make recursive call to getPermutation()

		Set<String> words = permutation(sub);

		// access each element from words

		for (String strNew : words) {

			for (int i = 0; i <= strNew.length(); i++) {

				// insert the permutation to the set

				permutations.add(strNew.substring(0, i) + first + strNew.substring(i));

			}

		}

		return permutations;

	}

	public static void main(String[] args) {

		// create an object of scanner class

		// Scanner input = new Scanner(System.in);

		// take input from users

		// System.out.print("Enter the string: ");

		// String data = input.nextLine();

		String data = "ABC";

		System.out.println("Permutations of " + data + ": \n" + permutation(data));

	}

}

}
